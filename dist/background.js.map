{"version":3,"file":"background.js","mappings":";;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AEpHA;AACA;AACA;AACA;AACA","sources":["webpack://http-header-viewer/./src/background/index.ts","webpack://http-header-viewer/webpack/before-startup","webpack://http-header-viewer/webpack/startup","webpack://http-header-viewer/webpack/after-startup"],"sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nlet requestHeaders = {};\nlet currentTabDomain = null;\n// 监听标签页更新\nchrome.tabs.onUpdated.addListener((tabId, changeInfo, tab) => {\n    if (changeInfo.status === 'complete' && tab.url) {\n        try {\n            const url = new URL(tab.url);\n            currentTabDomain = url.hostname;\n            console.log('Current domain updated:', currentTabDomain);\n            // 清理旧数据\n            requestHeaders = {};\n        }\n        catch (error) {\n            console.error('Error parsing URL:', error);\n        }\n    }\n});\n// 监听标签页切换\nchrome.tabs.onActivated.addListener((activeInfo) => __awaiter(void 0, void 0, void 0, function* () {\n    try {\n        const tab = yield chrome.tabs.get(activeInfo.tabId);\n        if (tab.url) {\n            const url = new URL(tab.url);\n            currentTabDomain = url.hostname;\n            console.log('Current domain updated:', currentTabDomain);\n            // 清理旧数据\n            requestHeaders = {};\n        }\n    }\n    catch (error) {\n        console.error('Error getting tab info:', error);\n    }\n}));\n// 创建请求过滤器\nconst createRequestFilter = () => {\n    if (!currentTabDomain)\n        return { urls: [] };\n    return {\n        urls: [\n            `*://${currentTabDomain}/*`,\n            `*://*.${currentTabDomain}/*`\n        ]\n    };\n};\n// 监听请求头\nchrome.webRequest.onSendHeaders.addListener((details) => {\n    if (!currentTabDomain)\n        return;\n    try {\n        const requestUrl = new URL(details.url);\n        // 只处理当前域名下的请求\n        if (requestUrl.hostname === currentTabDomain || requestUrl.hostname.endsWith(`.${currentTabDomain}`)) {\n            console.log('Request headers captured:', details.url);\n            if (details.requestHeaders) {\n                const key = `${Date.now()}_${details.requestId}`;\n                requestHeaders[key] = {\n                    headers: details.requestHeaders,\n                    url: details.url,\n                    timestamp: Date.now()\n                };\n                console.log('Headers for', details.url, ':', details.requestHeaders);\n            }\n        }\n    }\n    catch (error) {\n        console.error('Error processing request:', error);\n    }\n}, { urls: [\"<all_urls>\"] }, // 监听所有请求，在回调中过滤\n[\"requestHeaders\", \"extraHeaders\"] // 添加 extraHeaders 权限\n);\n// 监听请求开始\nchrome.webRequest.onBeforeRequest.addListener((details) => {\n    console.log('Request started:', details.url);\n}, { urls: [\"<all_urls>\"] });\n// 监听请求完成\nchrome.webRequest.onCompleted.addListener((details) => {\n    console.log('Request completed:', details.url);\n}, { urls: [\"<all_urls>\"] });\n// 监听请求错误\nchrome.webRequest.onErrorOccurred.addListener((details) => {\n    console.log('Request error:', details.url, details.error);\n}, { urls: [\"<all_urls>\"] });\n// 定期清理旧的请求数据\nsetInterval(() => {\n    const now = Date.now();\n    Object.keys(requestHeaders).forEach(key => {\n        if (now - requestHeaders[key].timestamp > 300000) { // 5分钟后清理\n            delete requestHeaders[key];\n        }\n    });\n}, 60000); // 每分钟清理一次\n// 处理来自 popup 的消息\nchrome.runtime.onMessage.addListener((request, sender, sendResponse) => {\n    console.log('Message received:', request);\n    if (request.type === 'getHeaders') {\n        // 按时间戳排序，最新的请求在前\n        const sortedHeaders = Object.entries(requestHeaders)\n            .sort(([, dataA], [, dataB]) => dataB.timestamp - dataA.timestamp)\n            .reduce((obj, [key, value]) => {\n            obj[key] = value;\n            return obj;\n        }, {});\n        console.log('Sending headers:', sortedHeaders);\n        sendResponse(sortedHeaders);\n    }\n    return true; // 保持消息通道开放\n});\n","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = {};\n__webpack_modules__[\"./src/background/index.ts\"]();\n",""],"names":[],"sourceRoot":""}